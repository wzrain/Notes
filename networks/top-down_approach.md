# Chapter 1 计算机网络与因特网
## 1.5 协议层次及其服务模型
利用分层体系，可以定义良好的大而复杂系统的某一部分，模块化，每一层易于改变，其余部分保持不变。\
潜在缺点是某一层可能会重复低层的功能，以及某一层可能需要在其他层才出现的信息。
* 应用层 \
包含网络应用程序以及协议，例如HTTP，SMTP（电子邮件），FTP（端系统文件传送）。应用层信息分组被称为报文（messages）。
* 运输层 \
运输层在应用程序端点之间传送应用层报文，有两个协议（TCP和UDP）。TCP提供面向连接的服务，包括保证应用层报文发送以及流量控制。TCP将长报文分成短的报文段（segments），这样网络拥塞时，源端可以减缓传输速率。UDP提供无连接服务，无可靠性，流量控制，拥塞控制。
* 网络层 \
网络层将数据报（datagrams）在主机（host）之间传递。源主机中的传输层协议把传输层报文段以及目的地址传给网络层。网络层将报文段传输给目的主机的传输层。\
IP协议定义了数据报中的字段以及端系统和路由器如何处理这些字段。网络层也包含路由协议，决定数据报如何从源到目的被路由。路由协议有很多种。
* 链路层 \
网络层通过一系列路由器路由数据报，为了将数据报从一个节点（路由器或者主机）运送到另一个节点，网络层依赖数据链路层的服务。在每个节点，网络层将数据报传递给链路层服务，链路层将数据报传送给下一个节点。在下一个节点数据报被传递回网络层。\
某些链路层协议提供可靠传输（节点间可靠传输，与TCP不同（端系统之间））。链路层协议有以太网，WiFi等。数据报传输中可能经过多个链路，不同链路的协议可能不同。链路层包在本书被称为帧（frames）。
* 物理层 \
物理层将链路层帧的每个比特从节点移动到另一个节点。

# Chapter 3 运输层
## 3.2 多路复用与多路分解
将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。从不同套接字接收数据，封装对应的首部信息生成报文段，传递到网络层，这些工作是多路复用。

## 3.3 无连接运输：UDP
UDP除了复用/分解功能以及少量差错检测外没有对IP增加别的东西。UDP从应用进程得到数据，封装源端口和目的端口字段（用于多路复用和分解）以及其他两个小字段，直接交给网络层。由于发送与接收方的运输层实体没有握手，所以是无连接的。\
DNS是通常使用UDP的应用层协议。UDP为DNS查询报文封装首部字段，交给网络层，网络层发送给一个名字服务器。DNS查询进程等待响应，如果没有收到，则试图向另一个名字服务器发送查询或者通知应用程序收不到响应。

UDP对数据的发送时间控制更为精细。TCP的拥塞机制可能会遏制TCP的发送方，不断的重传忽略了可靠交付需要的实际时间。实时应用要求最小的发送速率且不希望延迟，可以容忍数据丢失。\
UDP无需建立连接，不会引入握手的时延。如果DNS运行在TCP上则会很慢。HTTP使用TCP，因为文本数据的web网页要求较高的可靠性。无连接也意味着无需维护连接状态，因此可以支持更多的活跃客户。\
UDP首部仅有8字节开销。TCP为20字节。\
UDP可以通过在应用程序自身建立可靠性机制（例如确认与重传机制）来支持可靠数据传输。

应用层数据占用UDP报文段的数据字段。对于DNS，数据字段包含查询或者响应报文，对于流式音频数据字段包括音频抽样数据。UDP首部包括四个字段，每个两个字节。源端口号和目标端口号用于多路分解，长度字段指示首部加数据的总长度（每个UDP数据包大小不同）。校验和字段用于差错检验，发送方对报文段所有16bit字的和进行反码运算（接收方将校验和与所有16bit字的和加在一起会得到全为1的结果，如果有不为1的位则说明出现了差错）。提供差错检测的原因是链路可靠性无法保证，路由器的内存也可能引入差错，因此需要根据端到端原则提供差错检测。

## 3.5 面向连接的运输：TCP
TCP连接提供的是全双工服务，数据可以双向流动。TCP连接是点对点的，不支持多播。\
发送缓存是三次握手初期设置的缓存，TCP可以从缓存中取出的数据最大为最大报文段长度（保证加上首部的报文能够适合单个链路层帧）。

TCP首部包括源端口号和目的端口号，以及校验和。报文段序号为报文段首字节的字节流编号。确认号为当前累积确认的字节流编号。接收窗口字段用于流量控制，首部长度字段用于指示首部长度（由于选项字段（用于发送接收方协商最大报文段长度或者高速网络环境下用作窗口调节因子）的存在，TCP首部长度可变，如果选项字段为空则首部长度为20字节）。此外还有6bit标志字段（ACK、RST、SYN、FIN等等）。

TCP在定期为某个报文段测量RTT（发送到收到确认的时间），并通过estRTT=(1-a) * estRTT + a * RTT，更新估计的RTT。RTT的偏差devRTT=(1-b) * devRTT + b * |RTT-estRTT|，超时时间为timeout=estRTT+4devRTT。出现超时后timeout将加倍，避免后续确认过早超时，前述的公式仅用于在收到新报文或者新ACK时计算新的超时时间。\
可靠传输可以靠超时重传实现（没有收到ACK时重传相同的报文段）。如果连续发送两个报文段，第一个ACK超时，则重传后重启定时器，只要第二个ACK在新定时器超时前到达即不需要重传第二个。如果第一个ACK超时前另外一个确认号更大的ACK到达（例如有可能是第一个ACK丢失），那么第一个报文也不需要被重传（累积确认）。\
如果某个包丢失，那么接收方由于累积确认可能会重复发送相同的确认号，发送方收到3个冗余ACK则执行快速重传，在超时之前就重传丢失的报文段。

流量控制消除发送方使得接收方缓存溢出的可能性。拥塞控制主要针对网络拥塞。流量控制中发送方维护接收窗口，表示接收方还有多少缓存空间。接收方将自己缓存的空闲空间随着报文的接收窗口字段发送给发送方，发送方通过跟踪最后ACK的字节和最后发送的字节来得到发送但是没有被确认的数据量，并将此数据量控制在接收方窗口大小范围内。\
如果接收方发送了一个声明接收窗口为0的报文，且之后没有任何新的报文要发送给发送方或者报文丢失，那么发送方会因为得不到接收窗口的更新而一直阻塞。TCP规范因此要求接收方窗口为0时，发送方继续发送大小为一字节的报文段，接收方因此会发送确认，并包含新的窗口值。

TCP建立连接时，客户端向服务器端发送特殊报文，SYN=1，随机选择初始序号client_isn，进入SYN_SENT状态。服务器分配缓存和变量，返回SYN=1，确认号client_isn+1，服务器选择初始序号server_isn，进入SYN_RCVD状态。客户端分配缓存和变量，返回SYN=0，确认号server_isn+1，此报文段可以携带数据，服务器接收后双方均进入ESTABLISHED状态。\
客户端关闭连接命令，FIN=1,，进入FIN_WAIT_1状态，接收ACK后进入FIN_WAIT_2状态，服务器进入CLOSN_WAIT状态。之后服务器也会发送FIN=1，进入LAST_ACK状态，客户端收到后返回ACK进入TIME_WAIT状态，等待特定时间后如果ACK丢失则重传，否则CLOSED。

## 3.7 TCP拥塞控制
TCP使得发送方根据所感知的网络拥塞程度限制发送速率。TCP跟踪拥塞窗口的大小，使得最近发送的字节减去最近被确认的字节既小于拥塞窗口也小于接收窗口。如果丢包（超时或者收到3个冗余ACK）则表明可能拥塞。\
TCP连接开始时进行慢启动，拥塞窗口较小（一个最大报文段长度），之后每次翻倍，达到阈值后进入拥塞避免状态，拥塞窗口大小线性增长（如果一个RTT发送n个报文段，则每个ACK会使窗口增加1/n个报文段大小）。出现超时时，重新开始慢启动，设置新的阈值为拥塞时窗口大小的一半。如果收到3个冗余ACK，说明个别报文丢失，不重新慢启动，而是快速重传并且仅将窗口大小减半，进行快速恢复。